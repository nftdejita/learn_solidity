ここでは、コントラクトを終了し、あるアカウントが行った入札を撤回する関数を作成し、オークションを終了する関数を作成します。

### 引き出し(Withdraw)
ローカル変数 `bal` (残高) を作成し、関数の呼び出し元が前回の引き出し以降に行った入札の合計値 (ライン 75) を格納する。この値を `bal` に代入するには、関数呼び出し元のアドレスをキーとして入札マッピングにアクセスします。

次に、関数呼び出し元のアドレスの値を、入札マッピングで0に設定します。

次に、その金額のETHをコントラクトから関数呼び出し元に転送し、`Withdraw`イベントを発信します（79行目）。

### 終了
関数呼び出し元がこの関数を実行し、オークションを終了する前に、特定の条件が満たされているかどうかを確認する必要があります。オークションが開始されている必要があり (行83)、オークションの終了日に達している必要があり (行84)、オークションがすでに終了していない必要があります (行85)。

オークションが終了したら、ステート変数 `ended` を `true` にセットします (行 87)。

誰かがオークションに参加して、NFTに入札したかどうかを調べます(88行目)。

入札があった場合、NFTをコントラクトから最高入札者に転送し（89行目）、最高入札者からコントラクトに送られたETHを、今度はNFTの売り手であるオークショニアーのアドレスに転送します（90行目）。

誰もNFTに入札しなかった場合、NFTをオークショニアに送り返します（92行目）。

最後に、`End`イベントを発行します(95行目)。

## ⭐️課題

1. NFTコントラクトをデプロイしてください。Learneth「Solidity NFT コース」で作成した NFT コントラクトを使用します。
2. tokenId 0 の NFT を自分自身に Mint します。
3. テスト用に、ステート変数 `endAt` に代入される値（ライン 54）を `7 日` から `5 分` に変更します。
4. このEnglishAuctionコントラクトをデプロイします。NFTコントラクトのアドレスを `_nft` パラメータの引数として使用し、 `_nftId` には 0、`_startingBid` には 1 を指定します。
5. オークションコントラクトのアドレスを `to` パラメータの引数として、NFT コントラクトの `approve` 関数をコールし、`tokenId` には 0 を指定します。
6. オークションコントラクトの `start` 関数を呼び出します。
7. アカウント1を使って2イーサ、アカウント2を使って3イーサを入札します。highestBidder` 関数を呼び出すと、アカウント2のアドレスが返されるはずです。
8. アカウント1を使って `withdraw` 関数を呼び出します。アカウント1の残高には、2イーサから取引手数料を差し引いた金額が表示されているはずです。
9. 5分経過したら、`end`関数を呼び出します。次に、`ended`関数を呼び出し、`true`を返します。

NFT コントラクトでは、tokenId 0 を指定して `ownerOf` 関数を呼び出すと、アカウント 2 のアドレスが返されるはずです。アカウント1の残高を見ると、取引手数料を差し引いて3Ether分増加しているはずです。
