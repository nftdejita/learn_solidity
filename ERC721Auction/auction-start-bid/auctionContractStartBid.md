このセクションでは、オークションを開始する関数とNFTに入札する関数を作成します。

### 開始
販売者にオークションを開始させる前に、いくつかの制御構造を使用して、必要な条件が満たされているかどうかを確認します。

まず、オークションがすでに開始されているかどうかを確認します（49行目）。それが開始され、ステート変数`started`が`true`を返す場合、関数を終了して例外をスローします。

チェックする2番目の条件は、売り手が関数を実行しているかどうかです（50行目）。コントラクトを`seller`ステート変数にデプロイするときにセラーのアドレスを格納する関数を既に作成しており、start関数を実行しているアカウントがセラーであるかどうかを確認できるようになりました。そうでない場合は、例外をスローします。

次に、オークションにかけられているNFTを売り手からコントラクトに転送します（52行目）。
ステート変数`started`を`true`に設定し（53行目）、オークションの終了日を作成します（54行目）。この場合、start関数が呼び出されてから7日となります。リテラル数の後に`days`のような接尾辞を使用して、時間の単位を指定できます。時間単位について詳しく知りたい場合は、<a href="https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units" target="_blank">Solidityに関するドキュメント</a>をご覧ください。 。

最後に、 `Start()`イベントを発行します（56行目）。

### 入札
関数の呼び出し元が入札する前に、特定の条件が満たされていることを確認する必要があります。オークションを開始する必要があり（60行目）、オークションを終了することはできず（61行目）、入札（callに添付された値）は現在の最高入札額（62行目）よりも高い必要があります。

ここで、新しい入札を行う前に、現在の最高入札者の入札額を保存します。
まず、入札者がいるかどうかを確認します（64行目）。この関数呼び出しが最初の入札である場合、次の行は関係ありません。
マッピング`bids`（34行目）では、入札者のキーである `address`を、入札者が撤回する前にオークションで入札したETHの合計額を表す値`uint`にマッピングします。
入札者がいる場合は、「highestBidder」の最後の入札（ `highestBid`）を、撤回する前に行った入札の合計値（65行目）に加算します。
入札者が最高入札者でなくなった場合に、入札者が入札に使用したETHを撤回できるようにするため、入札を保存します。

次に、関数を呼び出すアカウントに `highestBidder`を設定し（68行目）、呼び出しで送信された値である入札に` highestBid`を設定します（69行目）。

最後に、 `Bid`イベントを発行します（71行目）。

## ⭐️課題
1. NFTコントラクトを展開します。 「SolidityNFTコース」Learnethコースで作成したNFTコントラクトを使用できます。

2. tokenId0を使用してNFTを作成します。

3. このEnglishAuctionコントラクトを展開します。 NFTコントラクトのアドレスを`_nft`パラメータの引数として使用し、` _nftId`の場合は0、`_startingBid`の場合は1を使用します。

4. 　`to`パラメータの引数としてオークションコントラクトのアドレスを使用し、`tokenId`の場合は0を使用してNFTコントラクトの`approve`関数を呼び出します。これにより、コントラクトはオークションにかけられるトークンを転送することができます。

5. オークションコントラクトの「開始」機能を呼び出します。ここで`started`関数を呼び出すと、`true`が返されます。 `highestBid`関数を呼び出すと、1が返されます。

6. トランザクションに添付できる値を3Weiに設定し、オークションコントラクトの「入札」機能を呼び出します。 `highestBid`関数を呼び出すと、3が返されるはずです。