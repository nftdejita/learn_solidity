次のセクションでは、Solidity でデータを整理して保存するために使用できるデータ構造について説明します。

*配列*、*マッピング*、および*構造体*は、すべて*参照型です*。値型 (例: *booleans* や *integer*) とは異なり、参照型は値を直接保存しません。その代わり、値が格納されている場所を格納します。複数の参照型変数が同じ場所を参照する可能性があり、1つの変数の変更は他の変数に影響を与えるため、慎重に扱う必要があります。

Solidity では、配列は同じ型の値の順序付きリストを格納し、数値でインデックス付けされます。

配列には、コンパイル時の *固定サイズ* と *動的配列* の 2 種類があります。固定サイズ配列の場合、コンパイル前に配列のサイズを宣言する必要があります。動的配列のサイズは，コンパイル後に変更することができます．

### 配列の宣言
固定サイズの配列を宣言するには，配列の型，配列サイズ（角括弧内の整数），可視性，名前を指定します（9行目）．

動的配列も同様に宣言する．ただし、配列のサイズは指定せず、括弧の中は空白にしています（6行目）。

### 配列の初期化
配列の要素は，一度に初期化することもできますし（7行目），一つずつ初期化することもできます（arr[0] = 1；）．配列を宣言すると、その要素は自動的にデフォルト値0に初期化されます（9行目）。

### 配列の要素にアクセスする
配列の要素にアクセスするには、配列の名前とインデックスを大括弧で囲んで指定します（12行目）。

### 配列要素の追加
メンバ関数 `push()` を用いて、動的配列の末尾に要素を追加する (25行目)。

### 配列の要素の削除
`pop()` メンバ関数を用いて、動的配列の最後の要素を削除しています (31行目)。

`delete` 演算子を使うと、配列から特定のインデックスの要素を削除することができます (42行目)。

`delete` 演算子で要素を削除しても、他の要素はすべてそのままなので、配列の長さも変わりません。つまり、配列の長さは変わらないということです。これでは配列に隙間ができてしまいます。

配列の順番が重要でない場合は、配列の最後の要素を削除された要素の場所に移動するか (46行目)、マッピングを使用することができます。データ構造内の要素を削除する場合は、マッピングを使用する方がよいでしょう。

### 配列の長さ
メンバーの`length`を使用して、配列に格納されている要素の数を読み取ることができます（35行目）。

<a href="https://www.youtube.com/watch?v=vTxxCbwMPwo" target="_blank">配列に関するビデオチュートリアルをご覧ください</a>.

## ⭐️ 課題
1. `arr3`と呼ばれるパブリック固定サイズの配列を値0、1、2で初期化します。サイズをできるだけ小さくします。
2. `getArr（）`関数を変更して、`arr3`の値を返します。