ここでの目標は、ブロックチェーンにコードを格納することです。EVMは、クライアント（geth、parity）に、**Call Data**のどの部分を保存するかを伝える必要があります。  このステップでは、コンストラクタを除いたコントラクトを保存し（1回だけインプリメントされるため）、入力パラメータを保存する必要がないことを除いたものを保存します。


`CODECOPY`は最初のステップです。バイトコードをメモリにコピーし、イーサリアムクライアントがそれを消費できるようにします。 MUNCH! 

しかし待ってください...クライアントがバイトコードを**MUNCH**する前に、MUNCHするように指示する命令 - opcodeが必要なのです。これが `RETURN` というオペコードです。

一般的な仕様にあるように、コントラクトの作成の最後に、クライアント (geth, parity) はオペコード `RETURN` によってターゲットとなる値を受け取り、それをデプロイされたバイトコードの一部にすることで**永続化**するのです。 


`CODECOPY`に入ったら、**Stack**の上位3つの項目を見てください。

```
0: 0x0000000000000000000000000000000000000000000000000000000000000000
1: 0x0000000000000000000000000000000000000000000000000000000000000055
2: 0x000000000000000000000000000000000000000000000000000000000000003e
```

*お使いのスタックでは、`1`と`2`が若干異なる場合があります。 コンパイラのバージョンによる違いかもしれません。*

**これらは `CODECOPY` のパラメータです。**

注記： *codecopy(t, f, s)* - コード位置 **f** からメモリ位置 **t** に **s** バイトをコピーします。

- (**t**)は、コピーされたコードが **メモリ** に配置されるオフセットです。この例では、(すべてゼロ)コードはメモリの先頭にコピーされます。
- (**f**)はコピー元の **calldata** 内のオフセットです 
- (**s**)はコピーするバイト数  


`CODECOPY`が実行された後、(*step into*ボタンをクリックして)コピーされたコードは以下のようになります。`0x6080604052600080fdfea265627a7a7231582029bb0975555a15a155e2cf28e025c8d492f0613bfb5cbf96399f6dbd4ea6fc9164736f6c63430005110032` in memory.  **この値を(X)**と呼ぶことにします。


デバッガの**メモリ**パネルを見てみましょう。
メモリ**パネルに表示されるのは、先ほどの0xの数字ではありません。
```
0x0: 6080604052600080fdfea265627a7a72 ????R??????ebzzr
0x10: 31582029bb0975555a15a155e2cf28e0 1X ?? uUZ??U????
0x20: 25c8d492f0613bfb5cbf96399f6dbd4e ?????a?????9?m?N
0x30: a6fc9164736f6c634300051100320000 ???dsolcC????2??
0x40: 00000000000000000000000000000000 ????????????????
0x50: 000000000000000000000000000000a0 ??????????????? 
0x60: 00000000000000000000000000000000 ????????????????
0x70: 00000000000000000000000000000000 ????????????????
0x80: 00000000000000000000000000000000 ????????????????
0x90: 00000000000000000000000000000002 ????????????????
```

0x0`, `0x10` などは位置です。次の数字はその位置のバイトコードです。 この後、クエスチョンマークと一見ランダムな文字と数字が続きます。 これは**Remix**がこれを文字列に変換しようとしているのです。 

つまり、最初の4つのセクションのバイトコードをくっつけると、次のようになります。
**0x6080604052600080fdfea265627a7a7231582029bb0975555a155e2cf28e0a6fc9164736f6c63430005110032** 最後のセクション - `0x90` には2があり、これは私がコンストラクターのパラメーターとして入力しているものです。

呼び出しデータ**パネルからの入力データです。
`0x6080604052348015600f57600080fd5b506040516093380380609383398181016040526020811015602f57600080fd5b81019080805190602001909291905050508060008190555050603e8060556000396000f3fe6080604052600080fdfea265627a7a7231582029bb0975555a15a155e2cf28e025c8d492f0613bfb5cbf96399f6dbd4ea6fc9164736f6c634300051100320000000000000000000000000000000000000000000000000000000000000002`
 **この値を(Y)と呼ぶことにする。**

これは、`(X)`が元のcalldata `(Y)`の部分集合であることを表しています。

(X)` は入力パラメータ `00000000000000000000002` を除いた calldata であり（これを保存する必要はありません）。

また、コンストラクタコード `6080604052348015600f57600080fd5b506040516093380380609383398181016040526020811015602f57600080fd5b810190805190602001909290505080600081905550603e8060556000396000f3fe` は含まないものです（1回だけ実行されるはずです）。


そこで、`CODECOPY` は calldata からバイトコードを取り出し、メモリにコピーします。

次のステップに進みましょう。
